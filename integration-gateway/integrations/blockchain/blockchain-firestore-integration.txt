}

/**
 * SynchronizationService handles scheduled synchronization between
 * Firestore and blockchain to maintain data consistency
 */
class SynchronizationService {
  constructor(hybridStorage) {
    this.hybridStorage = hybridStorage;
    this.firestore = admin.firestore();
  }
  
  /**
   * Perform full synchronization between Firestore and blockchain
   * @param {number} batchSize - Number of documents to process per batch
   * @returns {Promise<Object>} - Synchronization results
   */
  async performFullSync(batchSize = 100) {
    const results = {
      agents: await this._syncCollection('agents', batchSize),
      flights: await this._syncCollection('flights', batchSize),
      deliverables: await this._syncCollection('deliverables', batchSize)
    };
    
    // Record sync job in Firestore
    await this.firestore.collection('syncJobs').add({
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      results,
      type: 'full'
    });
    
    return results;
  }
  
  /**
   * Synchronize a specific collection
   * @private
   * @param {string} collection - Collection name
   * @param {number} batchSize - Batch size
   * @returns {Promise<Object>} - Sync results for collection
   */
  async _syncCollection(collection, batchSize) {
    const results = {
      processed: 0,
      verified: 0,
      repaired: 0,
      failed: 0,
      errors: []
    };
    
    try {
      // Get documents that haven't been verified
      const query = this.firestore.collection(collection)
        .where('blockchainVerified', '==', false)
        .limit(batchSize);
      
      const snapshot = await query.get();
      
      if (snapshot.empty) {
        return {
          ...results,
          message: `No unverified documents found in ${collection}`
        };
      }
      
      // Process each document
      for (const doc of snapshot.docs) {
        results.processed++;
        
        try {
          // Verify document
          const verification = await this.hybridStorage.verifyData(collection, doc.id);
          
          if (verification.verified) {
            // Mark as verified
            await doc.ref.update({
              blockchainVerified: true,
              lastVerification: admin.firestore.FieldValue.serverTimestamp()
            });
            
            results.verified++;
          } else {
            // Attempt to repair
            const repair = await this.hybridStorage.repairDataDiscrepancy(
              collection, 
              doc.id,
              'blockchain' // Use blockchain as source of truth
            );
            
            if (repair.success) {
              results.repaired++;
            } else {
              results.failed++;
              results.errors.push({
                id: doc.id,
                error: repair.error
              });
              
              // Log discrepancy for manual review
              await this.firestore.collection('syncDiscrepancies').add({
                collection,
                documentId: doc.id,
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                verification,
                repairAttempt: repair
              });
            }
          }
        } catch (error) {
          results.failed++;
          results.errors.push({
            id: doc.id,
            error: error.message
          });
          
          console.error(`Error processing ${collection}/${doc.id}:`, error);
        }
      }
      
      return results;
    } catch (error) {
      console.error(`Error syncing ${collection}:`, error);
      return {
        ...results,
        error: error.message
      };
    }
  }
  
  /**
   * Synchronize a specific document
   * @param {string} collection - Collection name
   * @param {string} docId - Document ID
   * @returns {Promise<Object>} - Sync result
   */
  async syncDocument(collection, docId) {
    try {
      // Verify document
      const verification = await this.hybridStorage.verifyData(collection, docId);
      
      if (verification.verified) {
        // Mark as verified
        await this.firestore.collection(collection).doc(docId).update({
          blockchainVerified: true,
          lastVerification: admin.firestore.FieldValue.serverTimestamp()
        });
        
        return {
          success: true,
          verified: true,
          message: 'Document verified successfully'
        };
      } else {
        // Attempt to repair
        const repair = await this.hybridStorage.repairDataDiscrepancy(
          collection, 
          docId,
          'blockchain' // Use blockchain as source of truth
        );
        
        if (repair.success) {
          return {
            success: true,
            verified: false,
            repaired: true,
            message: 'Document repaired successfully'
          };
        } else {
          // Log discrepancy for manual review
          await this.firestore.collection('syncDiscrepancies').add({
            collection,
            documentId: docId,
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            verification,
            repairAttempt: repair
          });
          
          return {
            success: false,
            verified: false,
            repaired: false,
            error: repair.error,
            message: 'Document verification failed and repair was unsuccessful'
          };
        }
      }
    } catch (error) {
      console.error(`Error syncing ${collection}/${docId}:`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

/**
 * EventSyncService handles synchronization of blockchain events to Firestore
 */
class EventSyncService {
  constructor(hybridStorage) {
    this.hybridStorage = hybridStorage;
    this.firestore = admin.firestore();
    this.provider = hybridStorage.provider;
    this.contracts = hybridStorage.contracts;
  }
  
  /**
   * Listen for blockchain events and sync to Firestore
   * @param {number} fromBlock - Block number to start from
   * @returns {Promise<void>}
   */
  async listenForEvents(fromBlock = 'latest') {
    // Listen for FlightVerification events
    this.contracts.flightVerification.on('FlightStarted', 
      async (flightId, pilotId, startTime, event) => {
        await this._processFlightStartedEvent(flightId, pilotId, startTime, event);
      }
    );
    
    this.contracts.flightVerification.on('FlightCompleted',
      async (flightId, endTime, rating, isPerfectFlight, rewardPoints, event) => {
        await this._processFlightCompletedEvent(
          flightId, endTime, rating, isPerfectFlight, rewardPoints, event
        );
      }
    );
    
    this.contracts.flightVerification.on('PerfectFlight',
      async (flightId, pilotId, timestamp, rewardPoints, event) => {
        await this._processPerfectFlightEvent(flightId, pilotId, timestamp, rewardPoints, event);
      }
    );
    
    // Listen for DeliverableAuthorization events
    this.contracts.deliverableAuthorization.on('DeliverableAuthorized',
      async (deliverableId, status, timestamp, event) => {
        await this._processDeliverableAuthorizedEvent(deliverableId, status, timestamp, event);
      }
    );
    
    // Listen for AgentRegistry events
    this.contracts.agentRegistry.on('AgentRegistered',
      async (agentId, agentType, squadronId, timestamp, event) => {
        await this._processAgentRegisteredEvent(agentId, agentType, squadronId, timestamp, event);
      }
    );
    
    // Listen for NFT events
    this.contracts.agentNFT.on('AgentMinted',
      async (tokenId, owner, agentType, timestamp, event) => {
        await this._processAgentMintedEvent(tokenId, owner, agentType, timestamp, event);
      }
    );
    
    this.contracts.agentNFT.on('Transfer',
      async (from, to, tokenId, event) => {
        await this._processNFTTransferEvent(from, to, tokenId, event);
      }
    );
    
    console.log('Started listening for blockchain events');
  }
  
  /**
   * Stop listening for blockchain events
   */
  stopListening() {
    this.contracts.flightVerification.removeAllListeners();
    this.contracts.deliverableAuthorization.removeAllListeners();
    this.contracts.agentRegistry.removeAllListeners();
    this.contracts.agentNFT.removeAllListeners();
    
    console.log('Stopped listening for blockchain events');
  }
  
  /**
   * Process FlightStarted event
   * @private
   */
  async _processFlightStartedEvent(flightId, pilotId, startTime, event) {
    try {
      // Check if flight exists in Firestore
      const flightRef = this.firestore.collection('flights').doc(flightId.toString());
      const flightDoc = await flightRef.get();
      
      if (flightDoc.exists) {
        // Update existing flight
        await flightRef.update({
          blockchainStatus: 'confirmed',
          blockchainStarted: true,
          pilotId: pilotId.toString(),
          startTime: new Date(startTime.toNumber()),
          blockchainTx: {
            transactionHash: event.transactionHash,
            blockNumber: event.blockNumber
          }
        });
      } else {
        // Create new flight record
        await flightRef.set({
          flightId: flightId.toString(),
          pilotId: pilotId.toString(),
          startTime: new Date(startTime.toNumber()),
          status: 'in-progress',
          blockchainStatus: 'confirmed',
          blockchainStarted: true,
          createdFromBlockchain: true,
          blockchainTx: {
            transactionHash: event.transactionHash,
            blockNumber: event.blockNumber
          }
        });
      }
      
      console.log(`Processed FlightStarted event for flight ${flightId}`);
    } catch (error) {
      console.error(`Error processing FlightStarted event for ${flightId}:`, error);
    }
  }
  
  /**
   * Process FlightCompleted event
   * @private
   */
  async _processFlightCompletedEvent(flightId, endTime, rating, isPerfectFlight, rewardPoints, event) {
    try {
      const flightRef = this.firestore.collection('flights').doc(flightId.toString());
      
      await flightRef.update({
        endTime: new Date(endTime.toNumber()),
        status: 'completed',
        rating: rating.toNumber(),
        isPerfectFlight,
        rewardPoints: rewardPoints.toNumber(),
        blockchainCompleted: true,
        blockchainTx: admin.firestore.FieldValue.arrayUnion({
          type: 'completion',
          transactionHash: event.transactionHash,
          blockNumber: event.blockNumber
        })
      });
      
      console.log(`Processed FlightCompleted event for flight ${flightId}`);
    } catch (error) {
      console.error(`Error processing FlightCompleted event for ${flightId}:`, error);
    }
  }
  
  /**
   * Process PerfectFlight event
   * @private
   */
  async _processPerfectFlightEvent(flightId, pilotId, timestamp, rewardPoints, event) {
    try {
      // Create perfect flight record
      await this.firestore.collection('perfectFlights').add({
        flightId: flightId.toString(),
        pilotId: pilotId.toString(),
        timestamp: new Date(timestamp.toNumber()),
        rewardPoints: rewardPoints.toNumber(),
        blockchainTx: {
          transactionHash: event.transactionHash,
          blockNumber: event.blockNumber
        }
      });
      
      // Update pilot's perfect flight count
      const pilotRef = this.firestore.collection('agents').doc(pilotId.toString());
      await pilotRef.update({
        perfectFlightCount: admin.firestore.FieldValue.increment(1),
        totalRewardPoints: admin.firestore.FieldValue.increment(rewardPoints.toNumber()),
        memoryAllocation: admin.firestore.FieldValue.increment(1000) // Bonus memory for perfect flights
      });
      
      console.log(`Processed PerfectFlight event for flight ${flightId}`);
    } catch (error) {
      console.error(`Error processing PerfectFlight event for ${flightId}:`, error);
    }
  }
  
  /**
   * Process DeliverableAuthorized event
   * @private
   */
  async _processDeliverableAuthorizedEvent(deliverableId, status, timestamp, event) {
    try {
      const deliverableRef = this.firestore.collection('deliverables').doc(deliverableId.toString());
      
      await deliverableRef.update({
        status: ['pending', 'approved', 'rejected'][status],
        reviewedAt: new Date(timestamp.toNumber()),
        blockchainAuthorized: true,
        blockchainTx: admin.firestore.FieldValue.arrayUnion({
          type: 'authorization',
          status: ['pending', 'approved', 'rejected'][status],
          transactionHash: event.transactionHash,
          blockNumber: event.blockNumber
        })
      });
      
      console.log(`Processed DeliverableAuthorized event for deliverable ${deliverableId}`);
    } catch (error) {
      console.error(`Error processing DeliverableAuthorized event for ${deliverableId}:`, error);
    }
  }
  
  /**
   * Process AgentRegistered event
   * @private
   */
  async _processAgentRegisteredEvent(agentId, agentType, squadronId, timestamp, event) {
    try {
      // Check if agent exists in Firestore
      const agentRef = this.firestore.collection('agents').doc(agentId.toString());
      const agentDoc = await agentRef.get();
      
      if (agentDoc.exists) {
        // Update existing agent
        await agentRef.update({
          blockchainRegistered: true,
          agentType: agentType.toString(),
          squadronId: squadronId.toString(),
          registrationDate: new Date(timestamp.toNumber()),
          blockchainTx: {
            transactionHash: event.transactionHash,
            blockNumber: event.blockNumber
          }
        });
      } else {
        // Create new agent record
        await agentRef.set({
          agentId: agentId.toString(),
          agentType: agentType.toString(),
          squadronId: squadronId.toString(),
          status: 'active',
          registrationDate: new Date(timestamp.toNumber()),
          createdFromBlockchain: true,
          blockchainRegistered: true,
          blockchainTx: {
            transactionHash: event.transactionHash,
            blockNumber: event.blockNumber
          }
        });
      }
      
      console.log(`Processed AgentRegistered event for agent ${agentId}`);
    } catch (error) {
      console.error(`Error processing AgentRegistered event for ${agentId}:`, error);
    }
  }
  
  /**
   * Process AgentMinted event
   * @private
   */
  async _processAgentMintedEvent(tokenId, owner, agentType, timestamp, event) {
    try {
      // Get token metadata
      const metadata = await this.contracts.agentNFT.getAgentMetadata(tokenId);
      const agentId = metadata.agentId;
      
      // Create or update NFT record
      await this.firestore.collection('nfts').doc(tokenId.toString()).set({
        tokenId: tokenId.toString(),
        owner,
        agentType,
        mintTimestamp: new Date(timestamp.toNumber()),
        agentId: agentId || null,
        blockchainTx: {
          transactionHash: event.transactionHash,
          blockNumber: event.blockNumber
        }
      });
      
      // If linked to an agent, update agent record
      if (agentId) {
        await this.firestore.collection('agents').doc(agentId).update({
          nftTokenId: tokenId.toString(),
          nftOwner: owner,
          nftMintTimestamp: new Date(timestamp.toNumber()),
          blockchainTx: admin.firestore.FieldValue.arrayUnion({
            type: 'nft_mint',
            transactionHash: event.transactionHash,
            blockNumber: event.blockNumber
          })
        });
      }
      
      console.log(`Processed AgentMinted event for token ${tokenId}`);
    } catch (error) {
      console.error(`Error processing AgentMinted event for ${tokenId}:`, error);
    }
  }
  
  /**
   * Process NFT Transfer event
   * @private
   */
  async _processNFTTransferEvent(from, to, tokenId, event) {
    try {
      // Update NFT ownership
      const nftRef = this.firestore.collection('nfts').doc(tokenId.toString());
      const nftDoc = await nftRef.get();
      
      if (nftDoc.exists) {
        const nftData = nftDoc.data();
        
        await nftRef.update({
          owner: to,
          transferHistory: admin.firestore.FieldValue.arrayUnion({
            from,
            to,
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            transactionHash: event.transactionHash,
            blockNumber: event.blockNumber
          })
        });
        
        // If linked to an agent, update agent record
        if (nftData.agentId) {
          await this.firestore.collection('agents').doc(nftData.agentId).update({
            nftOwner: to,
            ownershipHistory: admin.firestore.FieldValue.arrayUnion({
              previousOwner: from,
              newOwner: to,
              timestamp: admin.firestore.FieldValue.serverTimestamp(),
              transactionHash: event.transactionHash
            })
          });
        }
      }
      
      console.log(`Processed NFT Transfer event for token ${tokenId}`);
    } catch (error) {
      console.error(`Error processing NFT Transfer event for ${tokenId}:`, error);
    }
  }
}

// Initialize and export services
const hybridStorage = new HybridStorage({
  blockchain: {
    provider: process.env.BLOCKCHAIN_PROVIDER_URL || 'https://mainnet.infura.io/v3/YOUR_INFURA_KEY',
    contractAddresses: {
      flightVerification: process.env.FLIGHT_VERIFICATION_CONTRACT || '0x1234567890123456789012345678901234567890',
      deliverableAuthorization: process.env.DELIVERABLE_AUTH_CONTRACT || '0x0987654321098765432109876543210987654321',
      rewardDistribution: process.env.REWARD_DISTRIBUTION_CONTRACT || '0x5678901234567890123456789012345678901234',
      agentRegistry: process.env.AGENT_REGISTRY_CONTRACT || '0x4321098765432109876543210987654321098765',
      agentNFT: process.env.AGENT_NFT_CONTRACT || '0xabcdef1234567890abcdef1234567890abcdef12'
    }
  }
});

const syncService = new SynchronizationService(hybridStorage);
const eventSyncService = new EventSyncService(hybridStorage);

// Cloud Functions for blockchain-firestore integration
exports.startBlockchainSync = functions.region('us-west1').pubsub
  .schedule('every 2 hours')
  .onRun(async (context) => {
    console.log('Starting scheduled blockchain sync');
    const results = await syncService.performFullSync(100);
    console.log('Blockchain sync completed:', results);
    return null;
  });

// Cloud Function to sync a specific document
exports.syncDocument = functions.region('us-west1').https.onCall(async (data, context) => {
  // Check authentication
  if (!context.auth) {
    throw new functions.https.HttpsError(
      'unauthenticated',
      'The function must be called while authenticated.'
    );
  }
  
  // Check admin role
  const user = await admin.firestore().collection('users').doc(context.auth.uid).get();
  if (!user.exists || !user.data().roles?.admin) {
    throw new functions.https.HttpsError(
      'permission-denied',
      'Only administrators can manually sync documents.'
    );
  }
  
  // Get parameters
  const { collection, docId } = data;
  
  if (!collection || !docId) {
    throw new functions.https.HttpsError(
      'invalid-argument',
      'Collection and document ID are required.'
    );
  }
  
  // Perform sync
  const result = await syncService.syncDocument(collection, docId);
  return result;
});

// Cloud Function to start event listener (on startup)
exports.startBlockchainEventListener = functions.region('us-west1')
  .pubsub.topic('system-startup')
  .onPublish(async (message) => {
    try {
      await eventSyncService.listenForEvents();
      console.log('Started blockchain event listener');
      return null;
    } catch (error) {
      console.error('Error starting blockchain event listener:', error);
      return null;
    }
  });

// HTTP endpoint to manually start event listener
exports.manualStartEventListener = functions.region('us-west1')
  .https.onRequest(async (req, res) => {
    try {
      // Check API key for authorization
      const apiKey = req.headers['x-api-key'];
      
      if (apiKey !== process.env.BLOCKCHAIN_ADMIN_API_KEY) {
        res.status(403).json({ error: 'Unauthorized' });
        return;
      }
      
      await eventSyncService.listenForEvents();
      res.json({ success: true, message: 'Blockchain event listener started' });
    } catch (error) {
      console.error('Error starting event listener:', error);
      res.status(500).json({ error: error.message });
    }
  });

// HTTP endpoint to manually stop event listener
exports.manualStopEventListener = functions.region('us-west1')
  .https.onRequest(async (req, res) => {
    try {
      // Check API key for authorization
      const apiKey = req.headers['x-api-key'];
      
      if (apiKey !== process.env.BLOCKCHAIN_ADMIN_API_KEY) {
        res.status(403).json({ error: 'Unauthorized' });
        return;
      }
      
      eventSyncService.stopListening();
      res.json({ success: true, message: 'Blockchain event listener stopped' });
    } catch (error) {
      console.error('Error stopping event listener:', error);
      res.status(500).json({ error: error.message });
    }
  });

// Trigger for syncing new agents to blockchain
exports.onAgentCreated = functions.region('us-west1')
  .firestore.document('agents/{agentId}')
  .onCreate(async (snapshot, context) => {
    try {
      const agentId = context.params.agentId;
      const agentData = snapshot.data();
      
      // Check if already registered on blockchain
      if (agentData.blockchainRegistered) {
        return null;
      }
      
      // Register on blockchain
      const result = await hybridStorage.storeAgent(agentData);
      
      console.log(`Agent ${agentId} registered on blockchain:`, result);
      return null;
    } catch (error) {
      console.error('Error registering agent on blockchain:', error);
      return null;
    }
  });

// Trigger for syncing new flights to blockchain
exports.onFlightCreated = functions.region('us-west1')
  .firestore.document('flights/{flightId}')
  .onCreate(async (snapshot, context) => {
    try {
      const flightId = context.params.flightId;
      const flightData = snapshot.data();
      
      // Check if already registered on blockchain
      if (flightData.blockchainRegistered) {
        return null;
      }
      
      // Register on blockchain
      const result = await hybridStorage.storeFlight(flightData);
      
      console.log(`Flight ${flightId} registered on blockchain:`, result);
      return null;
    } catch (error) {
      console.error('Error registering flight on blockchain:', error);
      return null;
    }
  });

// Trigger for syncing new deliverables to blockchain
exports.onDeliverableCreated = functions.region('us-west1')
  .firestore.document('deliverables/{deliverableId}')
  .onCreate(async (snapshot, context) => {
    try {
      const deliverableId = context.params.deliverableId;
      const deliverableData = snapshot.data();
      
      // Check if already registered on blockchain
      if (deliverableData.blockchainRegistered) {
        return null;
      }
      
      // Register on blockchain
      const result = await hybridStorage.storeDeliverable(deliverableData);
      
      console.log(`Deliverable ${deliverableId} registered on blockchain:`, result);
      return null;
    } catch (error) {
      console.error('Error registering deliverable on blockchain:', error);
      return null;
    }
  });

// API for blockchain-firestore integration
const app = express();
app.use(express.json());

// Middleware to check API key
const checkApiKey = (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  
  if (apiKey !== process.env.BLOCKCHAIN_API_KEY) {
    res.status(403).json({ error: 'Unauthorized' });
    return;
  }
  
  next();
};

app.use(checkApiKey);

// Endpoint to verify data between Firestore and blockchain
app.get('/api/verify/:collection/:docId', async (req, res) => {
  try {
    const { collection, docId } = req.params;
    
    const verification = await hybridStorage.verifyData(collection, docId);
    res.json(verification);
  } catch (error) {
    console.error('Verification error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint to repair data discrepancy
app.post('/api/repair/:collection/:docId', async (req, res) => {
  try {
    const { collection, docId } = req.params;
    const { source } = req.body;
    
    if (!source || (source !== 'firestore' && source !== 'blockchain')) {
      res.status(400).json({ error: 'Source must be either "firestore" or "blockchain"' });
      return;
    }
    
    const repair = await hybridStorage.repairDataDiscrepancy(collection, docId, source);
    res.json(repair);
  } catch (error) {
    console.error('Repair error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint to create NFT for an agent
app.post('/api/agents/:agentId/create-nft', async (req, res) => {
  try {
    const { agentId } = req.params;
    const { ownerAddress } = req.body;
    
    if (!ownerAddress) {
      res.status(400).json({ error: 'Owner address is required' });
      return;
    }
    
    const result = await hybridStorage.createNFTForAgent(agentId, ownerAddress);
    res.json(result);
  } catch (error) {
    console.error('NFT creation error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint to get NFT data for an agent
app.get('/api/agents/:agentId/nft', async (req, res) => {
  try {
    const { agentId } = req.params;
    
    const nftData = await hybridStorage.getAgentNFTData(agentId);
    res.json(nftData);
  } catch (error) {
    console.error('NFT data retrieval error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Export the Express API as a Firebase function
exports.blockchainFirestoreAPI = functions.region('us-west1').https.onRequest(app);

// Export classes for use in other modules
module.exports = {
  HybridStorage,
  SynchronizationService,
  EventSyncService,
  hybridStorage,
  syncService,
  eventSyncService,
  blockchainFirestoreAPI: exports.blockchainFirestoreAPI,
  startBlockchainSync: exports.startBlockchainSync,
  syncDocument: exports.syncDocument,
  startBlockchainEventListener: exports.startBlockchainEventListener,
  manualStartEventListener: exports.manualStartEventListener,
  manualStopEventListener: exports.manualStopEventListener,
  onAgentCreated: exports.onAgentCreated,
  onFlightCreated: exports.onFlightCreated,
  onDeliverableCreated: exports.onDeliverableCreated
};// Blockchain and Firestore Integration for AIXTIV
// This module bridges the blockchain with Firestore databases to provide
// hybrid storage capabilities with both immutable verification and fast queries

const admin = require('firebase-admin');
const functions = require('firebase-functions');
const { ethers } = require('ethers');
const crypto = require('crypto');

// Initialize Firebase if not already initialized
if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

/**
 * HybridStorage class provides a seamless interface to both blockchain and Firestore
 * - Uses Firestore for fast queries and rich data storage
 * - Uses blockchain for verification and immutability of critical data
 */
class HybridStorage {
  constructor(config) {
    this.firestore = admin.firestore();
    this.blockchainConfig = config.blockchain || {
      provider: 'https://mainnet.infura.io/v3/YOUR_INFURA_KEY',
      contractAddresses: {
        flightVerification: '0x1234567890123456789012345678901234567890',
        deliverableAuthorization: '0x0987654321098765432109876543210987654321',
        rewardDistribution: '0x5678901234567890123456789012345678901234',
        agentRegistry: '0x4321098765432109876543210987654321098765',
        agentNFT: '0xabcdef1234567890abcdef1234567890abcdef12'
      }
    };
    
    this.provider = new ethers.providers.JsonRpcProvider(this.blockchainConfig.provider);
    
    // Get ABIs (would be imported from separate files in production)
    this.contracts = {
      flightVerification: new ethers.Contract(
        this.blockchainConfig.contractAddresses.flightVerification,
        require('./abis/FlightVerification.json'),
        this.provider
      ),
      deliverableAuthorization: new ethers.Contract(
        this.blockchainConfig.contractAddresses.deliverableAuthorization,
        require('./abis/DeliverableAuthorization.json'),
        this.provider
      ),
      rewardDistribution: new ethers.Contract(
        this.blockchainConfig.contractAddresses.rewardDistribution,
        require('./abis/RewardDistribution.json'),
        this.provider
      ),
      agentRegistry: new ethers.Contract(
        this.blockchainConfig.contractAddresses.agentRegistry,
        require('./abis/AgentRegistry.json'),
        this.provider
      ),
      agentNFT: new ethers.Contract(
        this.blockchainConfig.contractAddresses.agentNFT,
        require('./abis/AIXTIVAgentNFT.json'),
        this.provider
      )
    };
  }
  
  // Connect wallet for transaction signing
  connectWallet(privateKey) {
    const wallet = new ethers.Wallet(privateKey, this.provider);
    
    // Connect contracts with wallet
    this.contracts.flightVerification = this.contracts.flightVerification.connect(wallet);
    this.contracts.deliverableAuthorization = this.contracts.deliverableAuthorization.connect(wallet);
    this.contracts.rewardDistribution = this.contracts.rewardDistribution.connect(wallet);
    this.contracts.agentRegistry = this.contracts.agentRegistry.connect(wallet);
    this.contracts.agentNFT = this.contracts.agentNFT.connect(wallet);
    
    return wallet;
  }
  
  /**
   * Store flight data in both Firestore and blockchain
   * @param {Object} flightData - Complete flight data
   * @returns {Promise<Object>} - Transaction receipt and Firestore ID
   */
  async storeFlight(flightData) {
    try {
      // Generate unique ID if not provided
      const flightId = flightData.flightId || this._generateId('flight');
      
      // First, store in Firestore for fast access
      const firestoreRef = this.firestore.collection('flights').doc(flightId);
      await firestoreRef.set({
        ...flightData,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        blockchainStatus: 'pending'
      });
      
      // Then, store critical data on blockchain
      const tx = await this.contracts.flightVerification.startFlight(
        flightId,
        flightData.pilotId,
        flightData.startTime || Date.now(),
        this._hashObject(flightData.expectedDeliverables || {})
      );
      
      const receipt = await tx.wait();
      
      // Update Firestore with blockchain receipt
      await firestoreRef.update({
        blockchainStatus: 'confirmed',
        blockchainTx: {
          transactionHash: receipt.transactionHash,
          blockNumber: receipt.blockNumber
        }
      });
      
      return {
        flightId,
        firestoreId: firestoreRef.id,
        transactionHash: receipt.transactionHash,
        blockNumber: receipt.blockNumber
      };
    } catch (error) {
      console.error('Error storing flight:', error);
      throw error;
    }
  }
  
  /**
   * Store agent data in both Firestore and blockchain
   * @param {Object} agentData - Complete agent data
   * @returns {Promise<Object>} - Transaction receipt and Firestore ID
   */
  async storeAgent(agentData) {
    try {
      // Generate unique ID if not provided
      const agentId = agentData.agentId || this._generateId('agent');
      
      // First, store in Firestore for fast access
      const firestoreRef = this.firestore.collection('agents').doc(agentId);
      await firestoreRef.set({
        ...agentData,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        blockchainStatus: 'pending'
      });
      
      // Then, store critical data on blockchain
      const tx = await this.contracts.agentRegistry.registerAgent(
        agentId,
        agentData.agentType,
        JSON.stringify(agentData.capabilities || {}),
        agentData.squadronId
      );
      
      const receipt = await tx.wait();
      
      // Update Firestore with blockchain receipt
      await firestoreRef.update({
        blockchainStatus: 'confirmed',
        blockchainTx: {
          transactionHash: receipt.transactionHash,
          blockNumber: receipt.blockNumber
        }
      });
      
      return {
        agentId,
        firestoreId: firestoreRef.id,
        transactionHash: receipt.transactionHash,
        blockNumber: receipt.blockNumber
      };
    } catch (error) {
      console.error('Error storing agent:', error);
      throw error;
    }
  }
  
  /**
   * Store deliverable data in both Firestore and blockchain
   * @param {Object} deliverableData - Complete deliverable data
   * @returns {Promise<Object>} - Transaction receipt and Firestore ID
   */
  async storeDeliverable(deliverableData) {
    try {
      // Generate unique ID if not provided
      const deliverableId = deliverableData.deliverableId || this._generateId('deliverable');
      
      // First, store in Firestore for fast access
      const firestoreRef = this.firestore.collection('deliverables').doc(deliverableId);
      await firestoreRef.set({
        ...deliverableData,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        blockchainStatus: 'pending'
      });
      
      // Then, store critical data on blockchain
      const tx = await this.contracts.deliverableAuthorization.createDeliverable(
        deliverableId,
        deliverableData.pilotId,
        deliverableData.ownerId,
        deliverableData.title || '',
        deliverableData.timestamp || Date.now()
      );
      
      const receipt = await tx.wait();
      
      // Update Firestore with blockchain receipt
      await firestoreRef.update({
        blockchainStatus: 'confirmed',
        blockchainTx: {
          transactionHash: receipt.transactionHash,
          blockNumber: receipt.blockNumber
        }
      });
      
      return {
        deliverableId,
        firestoreId: firestoreRef.id,
        transactionHash: receipt.transactionHash,
        blockNumber: receipt.blockNumber
      };
    } catch (error) {
      console.error('Error storing deliverable:', error);
      throw error;
    }
  }
  
  /**
   * Verify data between Firestore and blockchain
   * @param {string} collection - Firestore collection name
   * @param {string} id - Document ID
   * @returns {Promise<Object>} - Verification result
   */
  async verifyData(collection, id) {
    try {
      // Get Firestore data
      const docRef = this.firestore.collection(collection).doc(id);
      const doc = await docRef.get();
      
      if (!doc.exists) {
        return {
          verified: false,
          error: 'Document not found in Firestore'
        };
      }
      
      const firestoreData = doc.data();
      
      // Check blockchain data based on collection type
      let blockchainData;
      let verified = false;
      
      switch (collection) {
        case 'flights':
          blockchainData = await this.contracts.flightVerification.getFlight(id);
          verified = blockchainData.pilotId === firestoreData.pilotId;
          break;
          
        case 'agents':
          blockchainData = await this.contracts.agentRegistry.getAgent(id);
          verified = 
            blockchainData.agentType === firestoreData.agentType && 
            blockchainData.squadronId === firestoreData.squadronId;
          break;
          
        case 'deliverables':
          blockchainData = await this.contracts.deliverableAuthorization.getDeliverable(id);
          verified = 
            blockchainData.pilotId === firestoreData.pilotId && 
            blockchainData.ownerId === firestoreData.ownerId;
          break;
          
        default:
          return {
            verified: false,
            error: 'Unknown collection type'
          };
      }
      
      return {
        verified,
        firestoreData,
        blockchainData
      };
    } catch (error) {
      console.error(`Error verifying ${collection}/${id}:`, error);
      return {
        verified: false,
        error: error.message
      };
    }
  }
  
  /**
   * Repair data discrepancy between Firestore and blockchain
   * @param {string} collection - Firestore collection name
   * @param {string} id - Document ID
   * @param {string} source - Source of truth ('firestore' or 'blockchain')
   * @returns {Promise<Object>} - Repair result
   */
  async repairDataDiscrepancy(collection, id, source) {
    try {
      // Verify data first
      const verification = await this.verifyData(collection, id);
      
      if (verification.verified) {
        return {
          success: true,
          message: 'No discrepancy to repair'
        };
      }
      
      if (source === 'firestore') {
        // Update blockchain based on Firestore data
        switch (collection) {
          case 'agents':
            const agentData = verification.firestoreData;
            await this.contracts.agentRegistry.updateAgent(
              id,
              JSON.stringify(agentData.capabilities || {}),
              agentData.status,
              Date.now()
            );
            break;
            
          case 'deliverables':
            // For deliverables, we can't update directly, need to create a revision
            const deliverableData = verification.firestoreData;
            await this.firestore.collection('deliverableRevisions').add({
              deliverableId: id,
              originalData: verification.blockchainData,
              updatedData: deliverableData,
              updatedAt: admin.firestore.FieldValue.serverTimestamp()
            });
            break;
            
          default:
            return {
              success: false,
              error: `Repair from Firestore not supported for ${collection}`
            };
        }
      } else if (source === 'blockchain') {
        // Update Firestore based on blockchain data
        const docRef = this.firestore.collection(collection).doc(id);
        
        switch (collection) {
          case 'flights':
            const flightData = verification.blockchainData;
            await docRef.update({
              pilotId: flightData.pilotId,
              startTime: flightData.startTime.toNumber(),
              endTime: flightData.endTime.toNumber(),
              status: ['in-progress', 'completed', 'cancelled'][flightData.status],
              isPerfectFlight: flightData.isPerfectFlight,
              rating: flightData.rating.toNumber(),
              rewardPoints: flightData.rewardPoints.toNumber(),
              blockchainVerified: true,
              blockchainSync: {
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                source: 'blockchain_repair'
              }
            });
            break;
            
          case 'agents':
            const agentData = verification.blockchainData;
            await docRef.update({
              agentType: agentData.agentType,
              squadronId: agentData.squadronId,
              status: ['active', 'inactive', 'suspended'][agentData.status],
              capabilities: JSON.parse(agentData.capabilities),
              registrationDate: new Date(agentData.registrationTimestamp.toNumber()),
              blockchainVerified: true,
              blockchainSync: {
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                source: 'blockchain_repair'
              }
            });
            break;
            
          case 'deliverables':
            const deliverableData = verification.blockchainData;
            await docRef.update({
              pilotId: deliverableData.pilotId,
              ownerId: deliverableData.ownerId,
              title: deliverableData.title,
              createdAt: new Date(deliverableData.createdAt.toNumber()),
              reviewedAt: deliverableData.reviewedAt.toNumber() > 0 ? 
                new Date(deliverableData.reviewedAt.toNumber()) : null,
              status: ['pending', 'approved', 'rejected'][deliverableData.status],
              blockchainVerified: true,
              blockchainSync: {
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                source: 'blockchain_repair'
              }
            });
            break;
            
          default:
            return {
              success: false,
              error: `Repair from blockchain not supported for ${collection}`
            };
        }
      } else {
        return {
          success: false,
          error: 'Invalid source parameter'
        };
      }
      
      // Verify again after repair
      const verificationAfter = await this.verifyData(collection, id);
      
      return {
        success: verificationAfter.verified,
        message: verificationAfter.verified ? 
          'Data repaired successfully' : 
          'Repair attempted but verification still fails',
        verification: verificationAfter
      };
    } catch (error) {
      console.error(`Error repairing ${collection}/${id}:`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Get NFT token data for an agent
   * @param {string} agentId - Agent ID
   * @returns {Promise<Object>} - NFT data
   */
  async getAgentNFTData(agentId) {
    try {
      // Try to get token ID from blockchain
      const tokenId = await this.contracts.agentNFT.getTokenForAgent(agentId);
      
      // Get token metadata
      const metadata = await this.contracts.agentNFT.getAgentMetadata(tokenId);
      
      // Get token owner
      const owner = await this.contracts.agentNFT.ownerOf(tokenId);
      
      return {
        exists: true,
        tokenId: tokenId.toString(),
        agentType: metadata.agentType,
        expertise: metadata.expertise,
        memoryAllocation: metadata.memoryAllocation.toNumber(),
        mintTimestamp: metadata.mintTimestamp.toNumber(),
        owner
      };
    } catch (error) {
      // If token not found, check Firestore
      try {
        const agentDoc = await this.firestore.collection('agents').doc(agentId).get();
        
        if (!agentDoc.exists) {
          return {
            exists: false,
            error: 'Agent not found in blockchain or Firestore'
          };
        }
        
        const agentData = agentDoc.data();
        
        // Check if NFT data exists in Firestore
        if (agentData.nftTokenId) {
          return {
            exists: true,
            tokenId: agentData.nftTokenId,
            agentType: agentData.agentType,
            expertise: agentData.capabilities?.expertise || [],
            memoryAllocation: agentData.memoryAllocation || 4000,
            mintTimestamp: agentData.nftMintTimestamp || 0,
            owner: agentData.nftOwner || agentData.ownerId || '',
            source: 'firestore' // Indicate this came from Firestore, not blockchain
          };
        }
        
        return {
          exists: false,
          firestoreExists: true,
          error: 'Agent exists in Firestore but has no associated NFT'
        };
      } catch (firestoreError) {
        console.error('Error checking Firestore for agent:', firestoreError);
        return {
          exists: false,
          error: error.message,
          firestoreError: firestoreError.message
        };
      }
    }
  }
  
  /**
   * Create NFT for an existing agent
   * @param {string} agentId - Agent ID
   * @param {string} ownerAddress - Ethereum address of the owner
   * @returns {Promise<Object>} - NFT creation result
   */
  async createNFTForAgent(agentId, ownerAddress) {
    try {
      // Get agent data from Firestore
      const agentDoc = await this.firestore.collection('agents').doc(agentId).get();
      
      if (!agentDoc.exists) {
        return {
          success: false,
          error: 'Agent not found in Firestore'
        };
      }
      
      const agentData = agentDoc.data();
      
      // Check if NFT already exists
      const nftCheck = await this.getAgentNFTData(agentId);
      if (nftCheck.exists) {
        return {
          success: false,
          error: 'NFT already exists for this agent',
          tokenId: nftCheck.tokenId
        };
      }
      
      // Generate metadata
      const metadata = {
        name: `AIXTIV ${agentData.agentType} Agent`,
        description: `A specialized AI agent with expertise in ${agentData.capabilities?.expertise?.join(', ') || 'various fields'}`,
        image: `https://aixtiv.io/nft-assets/${agentData.agentType.toLowerCase().replace(' ', '-')}.png`,
        attributes: [
          {
            trait_type: 'Agent Type',
            value: agentData.agentType
          },
          {
            trait_type: 'Squadron',
            value: agentData.squadronId
          },
          {
            trait_type: 'Memory Allocation',
            value: agentData.memoryAllocation || 4000
          }
        ]
      };
      
      // Add expertise attributes
      if (agentData.capabilities?.expertise) {
        agentData.capabilities.expertise.forEach(exp => {
          metadata.attributes.push({
            trait_type: 'Expertise',
            value: exp
          });
        });
      }
      
      // Store metadata in IPFS or centralized storage (simplified)
      const metadataURI = `https://aixtiv.io/api/metadata/${agentId}`;
      
      // Store metadata in Firestore
      await this.firestore.collection('nftMetadata').doc(agentId).set({
        agentId,
        metadata,
        metadataURI,
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // Mint NFT on blockchain
      const tx = await this.contracts.agentNFT.mintAgentWithMetadata(
        ownerAddress,
        agentData.agentType,
        JSON.stringify(agentData.capabilities?.expertise || []),
        agentData.memoryAllocation || 4000,
        metadataURI
      );
      
      const receipt = await tx.wait();
      
      // Get token ID from event logs
      const mintEvent = receipt.events.find(e => e.event === 'AgentMinted');
      const tokenId = mintEvent.args.tokenId.toString();
      
      // Activate the agent (link token to agent ID)
      const activateTx = await this.contracts.agentNFT.activateAgent(tokenId, agentId);
      await activateTx.wait();
      
      // Update agent in Firestore
      await this.firestore.collection('agents').doc(agentId).update({
        nftTokenId: tokenId,
        nftOwner: ownerAddress,
        nftMintTimestamp: Date.now(),
        blockchainTx: {
          mintTxHash: receipt.transactionHash,
          mintBlockNumber: receipt.blockNumber
        }
      });
      
      return {
        success: true,
        tokenId,
        ownerAddress,
        transactionHash: receipt.transactionHash,
        blockNumber: receipt.blockNumber,
        metadataURI
      };
    } catch (error) {
      console.error('Error creating NFT for agent:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Generate hash of an object for blockchain storage
   * @private
   * @param {Object} obj - Object to hash
   * @returns {string} - Hash string
   */
  _hashObject(obj) {
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(obj))
      .digest('hex');
  }
  
  /**
   * Generate a unique ID
   * @private
   * @param {string} prefix - ID prefix
   * @returns {string} - Unique ID
   */
  _generateId(prefix) {
    const timestamp = Date.now().toString(36);
    const randomStr = Math.random().toString(36).substring(2, 8);
    return `${prefix}_${timestamp}_${randomStr}`;
  }
}